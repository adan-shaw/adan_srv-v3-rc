--lua 标准库--自动加载, 全局变量, 每个lua 虚拟机恒定
--http://www.yiibai.com/lua/lua_standard_libraries.html
--[[
注意: 标准库不需要装载, lua vm 一启动就自带 !!

1.  Error Handling
包括错误处理功能，如断言，误差 - 错误处理

2.  Memory Management
I包括与垃圾回收Lua中所解释的自动内存管理功能

3.  dofile ([filename])
它打开该文件并执行该文件作为一个块的内容
如果不带参数传递, 那么这个函数执行标准输入的内容, 这些错误将传播给调用者

4.  _G 
因而是保持全局环境全局变量（即，_G._G=_G）, LUA本身并不使用这个变量

5.  getfenv ([f])
返回当前的环境中使用的功能
f能够是一个Lua函数或数字, 指定在该协议栈级别的函数：1级是函数调用getfenv
如果给定的功能是不是一个Lua函数, 或者如果f是0, getfenv返回全局环境, 默认为f为1

6.  getmetatable (object)
如果对象没有元表, 返回nil, 否则, 如果对象的元表具有“__metatable”字段,返回相关值
否则, 返回给定对象的元表

7.  ipairs (t)
此函数读取表的索引和值

8.  load (func [, chunkname])
使用加载函数func获取其部分组块, 每次调用func必须返回与先前的结果连接字符串

9.  loadfile ([filename]))
类似于加载, 但是从文件的文件名或从标准输入得到的块, 如果没有给出文件名

10.   loadstring (string [, chunkname])
类似于加载, 但是从给定的字符串得到的组块

11.   next (table [, index])
允许程序遍历表的所有字段, 它的第一个参数是一个表, 它的第二个参数是该表的索引.
接下来返回表及其关联值的一个索引

12.   pairs (t)
暂停运行的协程, 传递给该方法的参数作为附加的返回值以恢复功能

13.   print (...)
暂停运行的协程, 传递给该方法的参数作为附加的返回值以恢复功能

14.   rawequal (v1, v2)
检查V1是否等于V2, 没有调用任何元方法, 返回一个布尔值

15.   rawget (table, index)
获取表[索引]的真正值, 而不调用任何元方法, 表必须是表, 索引可以是任何值

16.   rawset (table, index, value)
设置表[索引]值, 真正的值没有调用任何元方法

17.   select (index, ...)
如果索引是一个数字, 返回后的参数数量索引的所有参数, 否则, 索引必须是字符串“＃”
然后选择返回到额外参数总数

18.   setfenv (f, table)
设置要使用的特定函数的环境。f 是一个Lua函数或数字，指定在该协议栈级别的函数：1级是函数调用setfenv。 setfenv返回给定的功能。作为一种特殊情况，当f是0 setfenv改变正在运行的线程的环境。在这种情况下，setfenv不返回任何值。

19.   setmetatable (table, metatable)
设置元表对给定表（不能从Lua中改变其它类型的元表，只能从C）若元表为零，消除了给定表的元表
如果原来的metatable有一个“__metatable”字段, 将引发错误, 这个函数返回表

20.   tonumber (e [, base])
尝试将它的参数转换为数字, 如果参数已经是一个数字或一个字符串转换为一个数字, 
然后tonumber返回这个数, 否则返回nil

21.   tostring (e)
接收到任何类型的参数, 并将其转换为一个字符串, 一个合理的格式.

22.   type (v)
返回其唯一参数的类型, 编码为一个字符串, 
这个函数的可能结果是“nil”（字符串，而不是值为零），“数字”，“串”，“布尔”，“表”，“功能”，“线”和“用户数据”

23.   unpack (list [, i [, j] ])
返回从给定表中的元素

24.   _VERSION
全局变量（不是函数）保存包含当前翻译版本的字符

25.   Coroutines
包括协程操作功能


]]